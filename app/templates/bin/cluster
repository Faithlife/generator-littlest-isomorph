#!/usr/bin/env node
'use strict';

var cluster = require('cluster');
var config = require('../lib/config');
var recentCrashes = 0;

// All workers run `server`.
cluster.setupMaster({
  exec: require.resolve('./server')
});

// As the master, run the configured number of instances.
for (var i = 0; i < config.cluster.instances; i++) {
  cluster.fork(require('../data/env/' + config.env + '.json'));
}

// When any of those instances fail, restart them after a small delay. That
// delay gets longer the more crashes have occurred recently.
cluster.on('exit', function (worker, code, signal) {
  var delay = Math.pow(2, recentCrashes++) * 100;

  console.warn('Worker %s left with %s. Starting a new worker in %s ms...', worker.process.pid, signal || code, delay);

  setTimeout(cluster.fork, delay);
});

// This interval keeps a natural limit on the maximum delay at 3200 ms, as well
// as helping lower that delay to its minimum over time.
setInterval(function () {
  if (recentCrashes) {
    recentCrashes--;
  }
}, 1600);
